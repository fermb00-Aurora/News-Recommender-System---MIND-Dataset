import pandas as pd
from datetime import timedelta

def frequency_categorical_recommender(
    user_id,
    n_recommendations,
    behaviors_file="processed_behaviours_train.parquet",
    news_file="processed_news_train.parquet",
    use_recency=True,
    recency_weeks=2
):
    """
    Returns top n_recommendations articles from the category the user reads most frequently.
    The user_id, behaviors_file, and news_file must match your dataset's structure:
      - Behaviors DF columns: 
          user_id (object), time (datetime), history (object, space-sep IDs)
      - News DF columns:
          news_id (object), category (object), title (object), url (object)

    Parameters:
      user_id (str): The user ID from the 'behaviors' DataFrame.
      n_recommendations (int): Number of articles to recommend.
      behaviors_file (str): Path to the .parquet with behaviors data.
      news_file (str): Path to the .parquet with news data.
      use_recency (bool): Whether to filter user’s behavior to the last `recency_weeks` weeks.
      recency_weeks (int): Number of weeks to consider for recency-based filtering.

    Returns:
      recommendations (pd.DataFrame or None): 
        A DataFrame of recommended articles with columns [news_id, category, title, url].
      explanation (str):
        Explanation text describing the recommendation rationale.
        If no recommendations are found, returns (None, explanation).
    """

    # ---------------------------
    # 1) Load the data
    # ---------------------------
    df_behav = pd.read_parquet(behaviors_file)
    df_news = pd.read_parquet(news_file)

    # ---------------------------
    # 2) Filter for the single user
    # ---------------------------
    user_behav = df_behav[df_behav["user_id"] == user_id].copy()
    if user_behav.empty:
        return None, f"No behavior records found for user {user_id}"

    # ---------------------------
    # 3) (Optional) Recency-based filter
    # ---------------------------
    # Convert 'time' to datetime if not already
    user_behav["time"] = pd.to_datetime(user_behav["time"], errors="coerce")
    latest_time = user_behav["time"].max()
    if pd.isnull(latest_time):
        # If user has no valid times, just skip recency
        recent_behav = user_behav
    else:
        # Subset user’s behavior to the last X weeks
        threshold = latest_time - timedelta(weeks=recency_weeks)
        if use_recency:
            recent_behav = user_behav[user_behav["time"] >= threshold]
        else:
            recent_behav = user_behav

    # ---------------------------
    # 4) Combine and parse user’s history
    # ---------------------------
    # 'history' is a space-separated string of news IDs
    # Combine all user’s history into one list
    history_series = recent_behav["history"].dropna().astype(str)
    user_history_list = " ".join(history_series).split()
    if not user_history_list:
        return None, f"User {user_id} has no reading history in the last {recency_weeks} weeks."

    # ---------------------------
    # 5) Determine top category
    # ---------------------------
    # Map each read news_id to its category
    # Make sure 'news_id' is unique in df_news
    category_map = df_news.set_index("news_id")["category"]
    user_categories = pd.Series(user_history_list).map(category_map).dropna()

    if user_categories.empty:
        return None, "No category information found for the user's history."

    # The user’s most frequently read category
    top_category = user_categories.value_counts().idxmax()

    # ---------------------------
    # 6) Filter candidate articles
    # ---------------------------
    # Candidate = articles in the top category that the user has NOT read
    read_ids = set(user_history_list)
    candidates = df_news[df_news["category"] == top_category].copy()
    candidates = candidates[~candidates["news_id"].isin(read_ids)]

    # (If you want recency for articles, you can do so if you had a release date.)
    # For now, we just pick the first N
    recommendations = candidates.head(n_recommendations)

    # ---------------------------
    # 7) Prepare the explanation
    # ---------------------------
    if recommendations.empty:
        explanation = (
            f"Based on your history, you appear to favor **{top_category}** news. "
            "However, no unseen articles were found in that category."
        )
        return None, explanation
    else:
        explanation = (
            f"Based on your reading history, you appear to favor **{top_category}** news. "
            f"Here are {len(recommendations)} articles you haven't read yet:"
        )
        return recommendations[["news_id", "category", "title", "url"]], explanation

# ---------------------------
# EXAMPLE USAGE
# ---------------------------
if __name__ == "__main__":
    # Example user_id from your dataset
    example_user = "U13740"
    recs, expl = frequency_categorical_recommender(example_user, 5)
    if recs is not None:
        print(expl)
        print(recs)
    else:
        print(expl)
